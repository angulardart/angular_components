
# Simple HTML

Displays low-trust HTML with strict and flexible sanitization.

This component is focused on displaying localized or otherwise partially-trusted
HTML in the following use cases:

*   Light formatting (bold, italic, newlines).
*   Links to external domains (with a customisable whitelist).
*   Arbitrary click handlers on substrings within the text.

Mixing these features with text that cannot appear verbatim in the template (due
to, for example, use of the `Intl` library for localization) is otherwise
difficult. This component is the recommended alternative to calling methods like
[`bypassSecurityTrustHtml()`](https://pub.dartlang.org/documentation/angular/latest/angular.security/DomSanitizationService/bypassSecurityTrustHtml.html)
when inserting HTML into the DOM.


## Usage

Using the `<simple-html>` and `<simple-html-block>` components is generally
recommended in the following cases:

*   Displaying
    [i18n](https://en.wikipedia.org/wiki/Internationalization_and_localization)
    messages that need to contain light text formatting (such as bold, italics,
    lists, or custom styles), links to URLs outside the current app, or custom
    click handlers.
*   Displaying HTML generated outside of a template (e.g. HTML that is built
    server-side but displayed client-side).

The alternatives include:

*   Standard Angular interpolation with `{{` ... `}}`.
    *   This is the fastest and safest option and should always be preferred if
        you do not need any sort of mark-up inside the string.
*   Using the `[innerHtml]` directive with a string argument.
    *   This is secure but very strict; only very limited tags are allowed.
    *   The behaviour in case of mistakes may be surprising. (For example,
        invalid links are silently removed.)
    *   The permitted elements and attributes are defined by the
        [_SimpleNodeValidator](https://raw.githubusercontent.com/dart-lang/sdk/master/sdk/lib/html/dart2js/html_dart2js.dart)
        and the permitted URLs by the
        [_SameOriginUriPolicy](https://raw.githubusercontent.com/dart-lang/sdk/master/sdk/lib/html/dart2js/html_dart2js.dart).
*   Using the `[safeInnerHtml]` directive, or the `[innerHtml]` directive with a
    `SafeHtml` argument generated by `bypassSecurityTrustHtml()`.
    *   This is generally not secure, since absolutely all tags are allowed and
        there is no further line of defense between you and
        [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting). This should
        be used only if there is no alternative.

## Motivating example

You have a message for translation that contains simple HTML tags and can't
easily be broken into separate parts. A typical example would be an inline link:

```html
Please see our <a href="https://support.google.com">Help Center</a> for more information.
```

or some light formatting

```html
This is the <b>best</b> feature in Google history!
```

You have a few options:

1.  Include the message in the template in the normal way, `{{myMessage}}`. This
    won't work because the tags are stripped out by the sanitizer â€” the text
    appears, but the links and bold don't work.
1.  Move the tags into the template and split one message into three:

    ```html
    {{pleaseSeeMessage}}<a href="https://support.google.com">{{helpCenterMessage}}</a>{{forMoreInformationMessage}}
    ```

    This is a problem for localization because the word order is very different
    in different languages; for example, in some languages the link would
    naturally be at the end of the sentence. This is also problematic for
    translators who have to translate sentence fragments.

1.  Define a "micro-language" inside the message and parse each message on the
    way to the template. For example, you could include sentinel values in the
    message and then decompose the string with some custom code:

    ```
    List<String> get messageFragments => someMessage(_sentinel, _sentinel).split(_sentinel)
    ```

    Then refer to the fragments inside the template:

    ```html
    {{fragments[0]}} <a href="https://support.google.com">{{fragments[1]}}</a> {{fragments[2]}}
    ```

    This becomes quite complex and error-prone if the message includes more than
    a single tag, and also requires explicit handling and delegation for every
    message.

1.  Include the message straight into the DOM using the `innerHtml` directive:

    ```html
    <div [innerHtml]="seeHelpCenterMessage">
    ```

    If `seeHelpCenterMessage` is a plain string, it will be strictly sanitized
    and disallowed elements silently removed. To work around this,
    `seeHelpCenterMessage` may instead return a
    [`SafeHtml`](https://pub.dartlang.org/documentation/angular/latest/angular.security/SafeHtml-class.html)
    object. This object can be constructed by calling
    [`bypassSecurityTrustHtml()`](https://pub.dartlang.org/documentation/angular/latest/angular.security/DomSanitizationService/bypassSecurityTrustHtml.html)
    on the string. However, this is very dangerous because it disables _all_
    sanitization and allows all tags (even `<script>`). If the string
    accidentally contains user-controlled data, or the translator made a mistake
    and included a dubious tag (such as `<script>`) in their translation, it
    would also be placed straight into the DOM and open up the application to
    severe security risks such as XSS.

`<simple-html>` addresses many of these issues.

## Features

The `<simple-html>` component is an inline element that allows you the
flexibility to include basic text elements, such as bold, span, and links, while
retaining very strong sanitization for other tags and attributes. It also
simplifies the code because there is no need to wrap the message in a `SafeHtml`
object; you can just use the message directly.

*Before:*

```dart
MyComponent {
  SafeHtml get myMessage => _sanitizer.bypassSecurityTrustHtml(messages.someMessage);
}
```

```html
<my-template>
  <span [innerHtml]="myMessage"></span> <!-- Uh-oh, XSS risk. -->
</my-template>
```

*Now:*

```dart
MyComponent {
  // No code required!
}
```

```html
<my-template>
  <simple-html [contents]="messages.someMessage"></simple-html> <!-- No XSS risk -->
</my-template>
```

The `<simple-html-block>` component behaves similarly but is a block-level
element that can contain further block-level elements such as `<ul>`.

### Atomic updates

To simplify debugging, any unsupported HTML will blank the entire component and
print a loud debug message. This makes it less likely that you overlook these
errors in testing.

### Supported tags

See the
[component's documentation](https://github.com/dart-lang/angular_components/blob/master/lib/simple_html/simple_html.dart)
for the exact specification of what is supported. A general overview is:

*   `<simple-html>` supports the following safe inline elements:
    *   Basic text formatting: `<b>`, `<strong>`, `<i>`, `<em>`.
    *   Line breaks: `<br>`.
    *   Text grouping: `<span>`.
    *   Links: `<a href="...">` provided the destination matches the current
        [origin](https://en.wikipedia.org/wiki/Same-origin_policy), points to
        certain permitted URIs such as the Help Center, or uses the
        `doNotVerifyUrlDestinations` flag; see
        ([URI whitelisting](#uri-whitelisting)).
        *   The `rel` attributes are permitted.
        *   The `target` attribute is permitted provided `rel="noopener"` is
            set.
        *   The `title` attribute is permitted.
*   `<simple-html-block>` supports all of the above and the following safe block
    elements:
    *   Unordered lists: `<ul>` and `<li>`.
    *   Paragraphs: `<p>`.

The `class` attribute is permitted by all elements.

### URI whitelisting {#uri-whitelisting}

By default, only links with the
[same origin](https://en.wikipedia.org/wiki/Same-origin_policy) as the host page
as permitted.

Additional paths can be permitted through an optional Angular dependency. See
the
[simpleHtmlUriWhitelist](https://github.com/dart-lang/angular_components/blob/master/lib/simple_html/simple_html.dart)
token for details.

#### Allowing external URIs without a whitelist

There are cases where you can not use a whitelist:

*   when exposing a whitelist through client code is not acceptable, or
*   the whitelist is not fixed

When the URIs come from a *safe* source, such as internally sourced URIs, you
can consider enabling the `doNotVerifyUrlDestinations` flag. This will allow any
URI with the `http`, `https` or `mailto` scheme to be inserted, and should
therefore be used with caution.

For example:

```html
<my-template>
  <simple-html doNotVerifyUrlDestinations
               [contents]="internalMessages.someMessage"></simple-html>
</my-template>
```

### Custom click handling

The component provides a `(trigger)` output, which is fired whenever an `<a>`
element with the CSS class `trigger` is clicked by the user. This is intended
for introducing custom click handlers to specified portions of the text. A
simple example, firing an Analytics event when a certain word is clicked, might
define a message and handler in the component:

```dart
String get someMessage => 'Click <a class="trigger">here</a>.';

void recordAnalyticsEvent => _analytics.fire();
```

and then include it in the template:

```html
<simple-html [contents]="someMessage"
             (trigger)="recordAnalyticsEvent()"></simple-html>
```

By default, the normal behaviour of the link also occurs, such as navigation. So
if a user clicks "here" in this message

```html
Click <a href="//example.com" class="trigger" (trigger)="myTrigger()">here</a>
```

then they will navigate to example.com _and_ `myTrigger` will be executed.

The trigger definition can also refer to the original Angular
[`$event`](https://webdev.dartlang.org/angular/guide/template-syntax#event-and-event-handling-statements).
This can be useful for more advanced features such as:

*   Selectively preventing the default behaviour (such as navigation) by calling
    [`$event.preventDefault`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault).
*   Having multiple `trigger` elements with different behaviour in the same
    message. Which element was clicked can be identified by reading the
    [`$event.target`](https://developer.mozilla.org/en-US/docs/Web/API/Event/target)
    field.

### Limitations

The following is not yet supported:

*   Other elements and attributes that are probably safe but are not yet in
    demand (such as `blockquote`).
*   More dangerous cases (such as setting the URL of an iframe) must still be
    done using `bypassSecurity*` methods. (But preferably don't do this at all.)

## Migration

Migration from an existing `bypassSecurityTrustHtml()` solution is generally
straightforward. Basic steps:

1.  Import the Dart library
    `package:angular_components/simple_html/simple_html.dart` in your component
    file.
1.  Add the `SimpleHtmlComponent` to your
    [@Component](https://pub.dartlang.org/documentation/angular/latest/angular/Component-class.html)'s
    directive list.
1.  For each message that previously used `bypassSecurityTrustHtml()`, remove
    that call and use the string directly.
1.  In your template file, bind the message with either:
    *   `<simple-html [contents]="msg"></simple-html>` rather than `<span
        [innerHtml]="msg"></span>` (if only inline elements are required).
    *   `<simple-html-block [contents]="msg"></simple-html-block>` rather than
        `<div [innerHtml]="msg"></div>` (if inline and block elements are
        required).
1.  Verify that it works! See [*Testing*](#testing).
1.  Clean up unused dependencies (e.g. remove the `DomSanitizer` if your
    component no longer needs it).
1.  If possible, prevent future usage of the unsafe methods by adding a
    presubmit check.

Remember that `<simple-html>` is an
[inline-block](https://developer.mozilla.org/en-US/docs/Web/CSS/display) element
so, if you need other display types, you will need to apply a custom CSS class
or wrap it inside another element. Likewise `<simple-html-block>` is a
block-level element and therefore should not be placed inside inline elements.

### Testing

The easiest way to debug quickly is to test that the text appears correctly in a
local build of your application. Due to SimpleHtml's atomic updates, you will
either see the message in full or no message at all, and in the latter case a
helpful debug message will be printed to the browser console.

### Troubleshooting

Some common issues and remedies include:

*   **The message appears empty**
    *   Check the console for error messages. If your HTML was rejected, you
        should see a log message at `SHOUT` severity describing the problem.

